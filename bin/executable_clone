#!/bin/zsh

# clone++
# script relying on `gh`, `gum`, `fzf`, and `tmux` to allow fuzzy finding GitHub repositories,
# cloning them, setting up a fork, and opening in a tmux session.

# configuration is made through environment variables

# workspace where projects are cloned
WORKSPACE=${WORKSPACE:-"$HOME/projects"}
# github username used to setup a remote branch while forking
GITHUB_USERNAME=${GITHUB_USERNAME:-$(whoami)}
# github organizations, comma separated, used for searching
GITHUB_ORGANIZATIONS=$(echo "$GITHUB_ORGANIZATIONS" | xargs)
IFS=',' read -rA ORGANIZATIONS <<<"$GITHUB_ORGANIZATIONS"

function usage() {
  gum log --structured --level error "Usage: $0 [--org <organization>] [--refresh] [search-pattern]"
  gum log --structured --level info "Examples:"
  gum log --structured --level info "  $0                    - Search all repositories from configured organizations"
  gum log --structured --level info "  $0 pattern            - Search with initial pattern across all organizations"
  gum log --structured --level info "  $0 --org myorg        - Search only in myorg"
  gum log --structured --level info "  $0 --org myorg pattern - Search for pattern in myorg"
  gum log --structured --level info "  $0 --refresh          - Force refresh the repository cache"
  return 1
}

# Parse arguments
SPECIFIC_ORG=""
SEARCH_PATTERN=""
FORCE_REFRESH=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    --org)
      if [ "$#" -lt 2 ]; then
        gum log --structured --level error "--org requires an organization name"
        usage
      fi
      SPECIFIC_ORG="$2"
      shift 2
      ;;
    --refresh)
      FORCE_REFRESH=1
      shift
      ;;
    *)
      SEARCH_PATTERN="$1"
      shift
      ;;
  esac
done

# Determine which organizations to search
if [ -n "$SPECIFIC_ORG" ]; then
  ORGS_TO_SEARCH=("$SPECIFIC_ORG")
else
  ORGS_TO_SEARCH=("${ORGANIZATIONS[@]}")
fi

# Setup cache
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/clone"
mkdir -p "$CACHE_DIR"

# Create cache key based on organizations being searched
CACHE_KEY=$(echo "${(j:_:)ORGS_TO_SEARCH[@]}" | md5sum | cut -d' ' -f1)
CACHE_FILE="$CACHE_DIR/repos-$CACHE_KEY"
CACHE_MAX_AGE=$((7 * 24 * 60 * 60)) # 7 days in seconds

# Check if cache is valid
USE_CACHE=0
if [ -f "$CACHE_FILE" ] && [ "$FORCE_REFRESH" -eq 0 ]; then
  CACHE_AGE=$(( $(date +%s) - $(stat -c %Y "$CACHE_FILE" 2>/dev/null || stat -f %m "$CACHE_FILE" 2>/dev/null) ))
  if [ "$CACHE_AGE" -lt "$CACHE_MAX_AGE" ]; then
    USE_CACHE=1
    DAYS_OLD=$((CACHE_AGE / 86400))
    gum log --structured --level info "Using cached repository list ($DAYS_OLD days old)"
  fi
fi

# Fetch or use cached repositories
if [ "$USE_CACHE" -eq 1 ]; then
  REPO_LIST=$(cat "$CACHE_FILE")
else
  REPO_LIST=$(gum spin --spinner dot --title "Loading repositories..." -- sh -c "
    for org in ${(j: :)ORGS_TO_SEARCH[@]}; do
      gh repo list \"\$org\" --limit 1000 --json nameWithOwner --jq '.[].nameWithOwner' 2>/dev/null
    done
  ")
  # Save to cache
  echo "$REPO_LIST" > "$CACHE_FILE"
fi

# Filter with fzf
REPOSITORY_PATH=$(echo "$REPO_LIST" | fzf --query="$SEARCH_PATTERN" --prompt="Select repository: " --height=40% --reverse --border)

if [ -z "$REPOSITORY_PATH" ]; then
  return 0
fi

REPOSITORY_NAME=${REPOSITORY_PATH#*/}

gum log --structured --level info "Selected repository: $REPOSITORY_PATH"

if [ -d "$WORKSPACE/$REPOSITORY_NAME" ]; then
  gum log --structured --level info "$REPOSITORY_NAME already cloned in $WORKSPACE"
else
  gum log --structured --level info "Cloning $REPOSITORY_NAME in $WORKSPACE"
  gum spin --spinner dot --title "Cloning repository..." -- \
    gh repo clone "$REPOSITORY_PATH" "$WORKSPACE/$REPOSITORY_NAME"
fi

gum log --structured --level info "Forking and configuring project"
gum spin --spinner dot --title "Setting up fork..." -- sh -c "
  cd '$WORKSPACE/$REPOSITORY_NAME' && gh repo fork --remote-name '$GITHUB_USERNAME' --remote 2>/dev/null || true
  cd '$WORKSPACE/$REPOSITORY_NAME' && gh repo set-default '$REPOSITORY_PATH'
"

if gh api repos/"$GITHUB_USERNAME"/"$REPOSITORY_NAME" --method=PATCH -f delete_branch_on_merge=true >/dev/null 2>&1; then
    gum log --structured --level info "Branch deletion setting updated successfully"
else
    gum log --structured --level warn "Failed to update branch deletion setting"
fi

gum log --structured --level info "Enabling Git Secrets"
gum spin --spinner dot --title "Installing git secrets..." -- sh -c "
  cd '$WORKSPACE/$REPOSITORY_NAME' && git secrets --install 2>/dev/null || true
  cd '$WORKSPACE/$REPOSITORY_NAME' && git secrets --register-aws 2>/dev/null || true
"

# Create or attach to tmux session
SESSION_NAME=$(echo "$REPOSITORY_NAME" | tr '.' '-')

if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
  gum log --structured --level info "Attaching to existing tmux session: $SESSION_NAME"
  tmux attach-session -t "$SESSION_NAME"
else
  gum log --structured --level info "Creating new tmux session: $SESSION_NAME"
  tmux new-session -s "$SESSION_NAME" -c "$WORKSPACE/$REPOSITORY_NAME"
fi
